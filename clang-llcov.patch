Index: include/clang/Driver/Options.td
===================================================================
--- include/clang/Driver/Options.td	(revision 185922)
+++ include/clang/Driver/Options.td	(working copy)
@@ -490,6 +490,8 @@
 def flimit_debug_info : Flag<["-"], "flimit-debug-info">, Group<f_Group>, Flags<[CC1Option]>,
   HelpText<"Limit debug information produced to reduce size of debug binary">;
 def flimited_precision_EQ : Joined<["-"], "flimited-precision=">, Group<f_Group>;
+def fllcov : Flag<["-"], "fllcov">, Group<f_Group>, Flags<[CC1Option]>, HelpText<"Enable LLCov">;
+def fno_llcov : Flag<["-"], "fno-llcov">, Group<f_Group>, Flags<[CC1Option]>, HelpText<"Disable LLCov">;
 def flto : Flag<["-"], "flto">, Group<f_Group>;
 def fno_lto : Flag<["-"], "fno-lto">, Group<f_Group>;
 def fmacro_backtrace_limit_EQ : Joined<["-"], "fmacro-backtrace-limit=">,
Index: include/clang/Frontend/CodeGenOptions.def
===================================================================
--- include/clang/Frontend/CodeGenOptions.def	(revision 185922)
+++ include/clang/Frontend/CodeGenOptions.def	(working copy)
@@ -65,6 +65,7 @@
 CODEGENOPT(InstrumentForProfiling , 1, 0) ///< Set when -pg is enabled.
 CODEGENOPT(LessPreciseFPMAD  , 1, 0) ///< Enable less precise MAD instructions to
                                      ///< be generated.
+CODEGENOPT(LLCov  , 1, 0) ///< Enable LLCov
 CODEGENOPT(MergeAllConstants , 1, 1) ///< Merge identical constants.
 CODEGENOPT(NoCommon          , 1, 0) ///< Set when -fno-common or C++ is enabled.
 CODEGENOPT(NoDwarf2CFIAsm    , 1, 0) ///< Set when -fno-dwarf2-cfi-asm is enabled.
Index: include/clang/Basic/LangOptions.def
===================================================================
--- include/clang/Basic/LangOptions.def	(revision 185922)
+++ include/clang/Basic/LangOptions.def	(working copy)
@@ -132,6 +132,9 @@
 BENIGN_LANGOPT(DebuggerCastResultToId, 1, 0, "for 'po' in the debugger, cast the result to id if it is of unknown type")
 BENIGN_LANGOPT(DebuggerObjCLiteral , 1, 0, "debugger Objective-C literals and subscripting support")
 
+
+BENIGN_LANGOPT(LLCov , 1, 0, "llcov")
+
 BENIGN_LANGOPT(SpellChecking , 1, 1, "spell-checking")
 LANGOPT(SinglePrecisionConstants , 1, 0, "treating double-precision floating point constants as single precision constants")
 LANGOPT(FastRelaxedMath , 1, 0, "OpenCL fast relaxed math")
Index: lib/Frontend/CompilerInvocation.cpp
===================================================================
--- lib/Frontend/CompilerInvocation.cpp	(revision 185922)
+++ lib/Frontend/CompilerInvocation.cpp	(working copy)
@@ -406,6 +406,8 @@
     }
   }
 
+  Opts.LLCov = Args.hasArg(OPT_fllcov);
+
   Opts.InstrumentFunctions = Args.hasArg(OPT_finstrument_functions);
   Opts.InstrumentForProfiling = Args.hasArg(OPT_pg);
   Opts.EmitOpenCLArgMetadata = Args.hasArg(OPT_cl_kernel_arg_info);
Index: lib/Driver/Tools.cpp
===================================================================
--- lib/Driver/Tools.cpp	(revision 185922)
+++ lib/Driver/Tools.cpp	(working copy)
@@ -1742,6 +1742,25 @@
     addSanitizerRTLinkFlagsLinux(TC, Args, CmdArgs, "ubsan_cxx", false);
 }
 
+/// If LLCov is enabled, add appropriate linker flags (Linux).
+static void addLLCovRTLinux(const ToolChain &TC, const ArgList &Args,
+                      ArgStringList &CmdArgs) {
+  // Add llcov linker flags when linking an executable, but not a shared object.
+  if ( //Args.hasArg(options::OPT_shared) ||
+      !Args.hasFlag(options::OPT_fllcov,
+                    options::OPT_fno_llcov, false))
+    return;
+  // LibLLCov is "../lib/clang/linux/ArchName/libclang_rt.llcov.a
+  llvm::SmallString<128> LibLLCov =
+      llvm::sys::path::parent_path(StringRef(TC.getDriver().Dir));
+  llvm::sys::path::append(LibLLCov, "lib", "clang", "linux", TC.getArchName());
+  llvm::sys::path::append(LibLLCov, "libclang_rt.llcov.a");
+  CmdArgs.push_back(Args.MakeArgString(LibLLCov));
+  CmdArgs.push_back("-ldl");
+  CmdArgs.push_back("-export-dynamic");
+  TC.AddCXXStdlibLibArgs(Args, CmdArgs);
+}
+
 static bool shouldUseFramePointer(const ArgList &Args,
                                   const llvm::Triple &Triple) {
   if (Arg *A = Args.getLastArg(options::OPT_fno_omit_frame_pointer,
@@ -2487,6 +2506,8 @@
     }
   }
 
+  Args.AddAllArgs(CmdArgs, options::OPT_fllcov);
+
   // Pass options for controlling the default header search paths.
   if (Args.hasArg(options::OPT_nostdinc)) {
     CmdArgs.push_back("-nostdsysteminc");
@@ -6100,6 +6121,9 @@
   if (Sanitize.needsMsanRt())
     addMsanRTLinux(getToolChain(), Args, CmdArgs);
 
+  // Add LLCov RT if instrumentation is requested
+  addLLCovRTLinux(getToolChain(), Args, CmdArgs);
+
   if (D.CCCIsCXX &&
       !Args.hasArg(options::OPT_nostdlib) &&
       !Args.hasArg(options::OPT_nodefaultlibs)) {
Index: lib/Driver/ToolChains.cpp
===================================================================
--- lib/Driver/ToolChains.cpp	(revision 185922)
+++ lib/Driver/ToolChains.cpp	(working copy)
@@ -328,6 +328,17 @@
     }
   }
 
+  // Add LLCov runtime library, if required.
+  if (Args.hasFlag(options::OPT_fllcov,
+                   options::OPT_fno_llcov, false)) {
+    if (isTargetIPhoneOS()) {
+      getDriver().Diag(diag::err_drv_clang_unsupported_per_platform)
+        << "-fllcov";
+    } else {
+      AddLinkRuntimeLib(Args, CmdArgs, "libclang_rt.llcov_osx.a");
+    }
+  }
+
   // Otherwise link libSystem, then the dynamic runtime library, and finally any
   // target specific static runtime library.
   CmdArgs.push_back("-lSystem");
Index: lib/CodeGen/BackendUtil.cpp
===================================================================
--- lib/CodeGen/BackendUtil.cpp	(revision 185922)
+++ lib/CodeGen/BackendUtil.cpp	(working copy)
@@ -159,6 +159,11 @@
   PM.add(createBoundsCheckingPass());
 }
 
+static void addLLCovPass(const PassManagerBuilder &Builder,
+                                    PassManagerBase &PM) {
+  PM.add(createLLCovPass());
+}
+
 static void addAddressSanitizerPasses(const PassManagerBuilder &Builder,
                                       PassManagerBase &PM) {
   const PassManagerBuilderWrapper &BuilderWrapper =
@@ -263,6 +268,13 @@
                            addThreadSanitizerPass);
   }
 
+  if (CodeGenOpts.LLCov) {
+    PMBuilder.addExtension(PassManagerBuilder::EP_ScalarOptimizerLate,
+                           addLLCovPass);
+    PMBuilder.addExtension(PassManagerBuilder::EP_EnabledOnOptLevel0,
+                           addLLCovPass);
+  }
+
   // Figure out TargetLibraryInfo.
   Triple TargetTriple(TheModule->getTargetTriple());
   PMBuilder.LibraryInfo = new TargetLibraryInfo(TargetTriple);
